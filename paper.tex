\documentclass[twocolumn,longbibliography]{quantumarticle-customized}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[pdfpagelabels,pdftex,bookmarks,breaklinks]{hyperref}
\usepackage{tikz}
\usepackage[all]{hypcap}
\hypersetup{colorlinks,citecolor=blue,urlcolor=blue,linkcolor=blue}

\input{Qcircuit}
\newcommand{\qH}{\gate{H}}
\newcommand{\qT}{\gate{T}}
\newcommand{\qTi}{\gate{T^\dagger}}
\newcommand{\qS}{\gate{S}}
\newcommand{\qSi}{\gate{S^\dagger}}
\newcommand{\qA}{\lstick{|A\rangle}}
\newcommand{\qO}{\lstick{|0\rangle}}

\title{Halving the cost of quantum addition}
\author{Craig Gidney}
\affiliation{Google, Santa Barbara, CA 93117, USA}
\email{craiggidney@google.com}

\def\sectionautorefname{Section}

\begin{document}
\maketitle

\begin{abstract}
We improve the number of T gates needed to perform an $n$-bit adder from $8n + O(1)$ \cite{Cuccaro2004, Amy2013, AustinDiscussionsAndEmails2017} to $4n + O(1)$.
We do so via a ``temporary AND gate" construction, which uses four T gates to store the logical-AND of two qubits into an ancilla and zero T gates to later erase the ancilla.

Temporary AND gates are a generally useful tool when optimizing T-count.
They can be applied to integer arithmetic, modular arithmetic, rotation synthesis, the quantum Fourier transform, Shor's algorithm, Grover oracles, and many other circuits.
Because T gates dominate the cost of quantum computation based on the surface code, and the temporary AND gate is widely applicable, our constructions represent a significant reduction in projected costs of quantum computation.

In addition to our $n$-bit adder circuit with T-count of $4n + O(1)$, we show how to construct an $n$-bit controlled adder circuit with T-count of $8n + O(1)$, and a temporary adder that can be computed for the same cost as the normal adder but whose result can be kept until later uncomputed at no T-count.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

The surface code is a quantum error correcting code that works on a 2D nearest-neighbour array of qubits and achieves a threshold error rate of approximately 1\% [[[[cite so much]]]].
This makes the surface code a likely component in the architecture of future error corrected quantum computers, because 2D arrays of qubits with nearest-neighbor connections are possible with many qubit technologies [[[[cite so much]]]] and other known error correcting codes have lower thresholds or require stronger connectivity [[[[cite so much]]]].

One of the downsides of the surface code is that it has no cheap mechanism to apply non-Clifford operations such as $T$ gates.
Instead, $T$ gates are performed by distilling and consuming $|A\rangle = \frac{1}{\sqrt{2}} (|0\rangle + e^{i \pi/4} |1\rangle)$ states.
Consuming an $|A\rangle$ state to perform a T gate is simple, but distilling $|A\rangle$ states has significant cost.
Because T gates are so expensive for the surface code, and the surface code is a likely component of future quantum computers, it is important to consider and optimize the number of T gates used by quantum circuits.

In this paper, we focus on improving the number of T gates needed to perform Toffoli gates that will later be uncomputed by a second Toffoli gate.
We then apply these improvements.
The key ideas behind our construction are 1) perform the Toffoli indirectly by targeting a clean ancilla qubit and then using the ancilla to toggle the intended target, 2) don't uncompute and recompute the ancilla if it will be needed again, 3) if a T gate is being used to compute and/or uncompute an $|A\rangle$ state then just pass in and/or recover an $|A\rangle$ state instead, and 4) uncompute the ancilla by measuring it then applying a classically controlled fixup operation.
We refer to initializing the ancilla as ``computing the logical-AND of the controls", to uncomputing the ancilla as ``erasing the logical-AND", and to the combination of both pieces as a ``temporary AND gate".

Our paper is divided into six sections.
In \autoref{sec:introduction}, we motivate the problem and introduce terminology.
\autoref{sec:review} discusses how previous work on optimizing T gate counts improved the cost of matched pairs of Toffolis from 14 to 8.
In \autoref{sec:invest}, we show how to improve the T-count from 8 to 6 by investing and later recovering an $|A\rangle$ state instead of consuming it to perform T gates.
\autoref{sec:temporary-and} expands on those ideas with an ancilla erasing trick that improves the T-count from 6 to 4.
This leads to \autoref{sec:circuit-constructions}, where we demonstrate how to use our constructions to create low T-count circuits for several addition tasks and discuss other possible applications of our constructions.
Finally, \autoref{sec:conclusion} summarizes our contributions, and proves that at least two T gates are needed to perform a temporary AND.


\section{Previous Work}
\label{sec:review}

The textbook construction of a Toffoli gate uses seven T gates \cite{Nielsen2009} (see \autoref{fig:textbook-toffoli}).
Assuming we aren't permitted to involve other qubits or to share work with other operations, this construction is optimal \cite{Gosset2014}.

When optimizations can cross qubit and gate boundaries, the textbook construction isn't optimal.
For example, when several adjacent Toffoli gates share the same controls, all but one can be replaced by CNOT operations (see \autoref{fig:shared-controls}).

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1}&\qw & &   & & &\ctrl{1}&\qw  &\ctrl{1}&\qT &\qw     &\qw  &\ctrl{2}&\qw &\qw     &\qw  &\ctrl{2}&\qw &\qw \\
      &\ctrl{1}&\qw & & = & & &\targ   &\qTi &\targ   &\qT &\ctrl{1}&\qw  &\qw     &\qw &\ctrl{1}&\qw  &\qw     &\qw &\qw \\
      &\targ   &\qw & &   & & &\qw     &\qw  &\qH     &\qT &\targ   &\qTi &\targ   &\qT &\targ   &\qTi &\targ   &\qH &\qw \\
    }
  }
  \caption{
	Textbook Toffoli construction from \cite{Nielsen2009}.
	Uses eight Clifford gates and seven T gates.
  }
  \label{fig:textbook-toffoli}
\end{figure}

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1}&\ctrl{1}&\ctrl{1}&\ctrl{1}&\qw && &&&\qw     &\qw     &\qw     &\ctrl{1}&\qw     &\qw     &\qw     &\qw &\\
      &\ctrl{1}&\ctrl{2}&\ctrl{3}&\ctrl{4}&\qw &&=&&&\qw     &\qw     &\qw     &\ctrl{1}&\qw     &\qw     &\qw     &\qw &\\
      &\targ   &\qw     &\qw     &\qw     &\qw && &&&\ctrl{3}&\ctrl{2}&\ctrl{1}&\targ   &\ctrl{1}&\ctrl{2}&\ctrl{3}&\qw &\\
      &\qw     &\targ   &\qw     &\qw     &\qw && &&&\qw     &\qw     &\targ   &\qw     &\targ   &\qw     &\qw     &\qw &\\
      &\qw     &\qw     &\targ   &\qw     &\qw && &&&\qw     &\targ   &\qw     &\qw     &\qw     &\targ   &\qw     &\qw &\\
      &\qw     &\qw     &\qw     &\targ   &\qw && &&&\targ   &\qw     &\qw     &\qw     &\qw     &\qw     &\targ   &\qw &\\
    }
  }
  \caption{
	The T-count of $N$ adjacent Toffolis sharing the same controls is $0 \cdot N + O(1)$.
	The marginal T-count is 0 because each additional Toffoli can be replaced with CNOTs framing a root Toffoli.
  }
  \label{fig:shared-controls}
\end{figure}

It isn't common for adjacent Toffolis to have the same controls, but it is common for a Toffoli to later be uncomputed by a second matching Toffoli (i.e. for the Toffoli's effect to be temporary).
When this occurs, the three $T$ gates on the control qubits of the textbook construction can be omitted.
This introduces phase errors (see \autoref{fig:bad-phase-toffoli}), but the second Toffoli gate can uncompute those errors while uncomputing the state permutation \cite{Barenco1995} (see \autoref{fig:cancelled-bad-phase-toffoli}).

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1}&\qw &&      &&&\ctrl{1}     &\ctrl{1}&\qw && &&&\qw &\qw &\qw     &\qw  &\ctrl{2}&\qw &\qw     &\qw  &\qw &\qw \\
      &\ctrl{1}&\qw &&\cong &&&\qS          &\ctrl{1}&\qw &&=&&&\qw &\qw &\ctrl{1}&\qw  &\qw     &\qw &\ctrl{1}&\qw  &\qw &\qw \\
      &\targ   &\qw &&      &&&\gate{Z}\qwx &\targ   &\qw && &&&\qH &\qT &\targ   &\qTi &\targ   &\qT &\targ   &\qTi &\qH &\qw \\
    }
  }
  \caption{
	Starting with \autoref{fig:textbook-toffoli} then dropping T gates on the controls produces an operation with a T-count of 4 that performs the correct permutation.
	However, the operation introduces phase errors.
  }
  \label{fig:bad-phase-toffoli}
\end{figure}

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1}&\qw &\qw &\qw    &\qw &\qw &\ctrl{1}&\qw && &&&\ctrl{1}     &\ctrl{1}  &\qw &\qw &\qw    &\qw &\qw     &\ctrl{1}&\ctrl{1}     &\qw & \\
      &\ctrl{1}&\qw &\qw &\qw    &\qw &\qw &\ctrl{1}&\qw &&=&&&\qS          &\ctrl{1}  &\qw &\qw &\qw    &\qw &\qw     &\ctrl{1}&\qSi         &\qw & \\
      &\targ   &\qw &    &\ldots &    &    &\targ   &\qw && &&&\gate{Z}\qwx &\targ     &\qw &    &\ldots &    &        &\targ   &\gate{Z}\qwx &\qw & \\
    }
  }
  \caption{
	When two Toffolis form a compute/uncompute pair, they can cancel each others' phase errors.
	Fixes the problem with the construction in \autoref{fig:bad-phase-toffoli}, and achieves a per-Toffoli T-count of 4 for paired Toffolis \cite{Barenco1995}.
  }
  \label{fig:cancelled-bad-phase-toffoli}
\end{figure}

A typical $n$-bit quantum adder will contain $2n + O(1)$ Toffoli gates, implying a naive T-count of $14n + O(1)$.
However, almost all of the Toffoli gates in the first half of an adder are uncomputed by Toffoli gates in the second half.
This allows the T gates on the controls of the Toffoli gates to be omitted, reducing their T-count from 7 to 4 and the T-count of addition to $8n + O(1)$.

Even if a Toffoli isn't paired with a second Toffoli that uncomputes its effects, it is still possible to perform the Toffoli with T-count of 4 by using an ancilla, a measurement, and a conditional fixup operation \cite{Jones2013} (see \autoref{fig:jones-toffoli}).

\begin{figure}
  \resizebox{\linewidth}{!}{
    (a) \Qcircuit @R=0.7em @C=0.7em {
      &\blacktriangleright\qw     &\qw && &&&     &\qw &\ctrl{3}&\targ    &\qw     &\qTi &\qw     &\targ    &\ctrl{3}&\qw &\qw \\
      &\blacktriangleright\qwx\qw &\qw &&=&&&     &\qw &\qw     &\targ    &\ctrl{2}&\qTi &\ctrl{2}&\targ    &\qw     &\qw &\qw \\
      &\targ\qwx                  &\qw && &&&     &\qH &\qw     &\ctrl{-2}&\qw     &\qT  &\qw     &\ctrl{-2}&\qw     &\qH &\qw \\
      &                           &    && &&& \qO &\qw &\targ   &\qw      &\targ   &\qT  &\targ   &\qw      &\targ   &\qw &\qw \\
    }
  }
  \resizebox{\linewidth}{!}{
    (b) \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1}&\qw && &&&    &\blacktriangleright\qw     &\qw &\qw     &\qw &\qw    &\ctrl{1}       &\qw \\
      &\ctrl{2}&\qw &&=&&&    &\blacktriangleright\qwx\qw &\qw &\qw     &\qw &\qw    &\gate{Z}       &\qw \\
      &        &    && &&&\qO &\targ\qwx                  &\qS &\ctrl{1}&\qH &\meter &\cw\cwx\bullet &    \\
      &\targ   &\qw && &&&    &\qw                        &\qw &\targ   &\qw &\qw    &\qw            &\qw \\
    }
  }
  \caption{
	Ancilla-based Toffoli construction with a T-count of 4 and a T-depth of 1 from \cite{Jones2013}.
  }
  \label{fig:jones-toffoli}
\end{figure}


\section{Warm up: Reusing $|A\rangle$ states}
\label{sec:invest}

This paper started with an idea that improved the T-count of a single Toffoli gate from 7 to 6 in a surprising way, by performing the Toffoli indirectly instead of directly.
We started with a clean ancilla in the $|0\rangle$ state, applied a Toffoli to store the logical-AND of the two controls in the ancilla, used the ancilla to control a CNOT onto the intended target, then uncomputed the ancilla.

Initially, this indirect-Toffoli construction appears to have a T-count of 8.
However, as shown in \autoref{fig:indirect-toffoli}, the last T gate in the circuit is unnecessary.
In fact, it is actively harmful.
Dropping this T gate and the following Hadamard not only reduces the T-count from 8 to 7, it leaves the ancilla in an $|A\rangle$ state that can be consumed to perform a T gate elsewhere.
This improves the net T-count to 6.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1} &\qw && &&&    &\qw &\qw &\qw      &\qw  &\ctrl{3} &\qw &\qw      &\qw  &\qw &\qw       &\qw &\qw &\qw      &\qw  &\ctrl{3} &\qw &\qw      &\qw  &\qw &\qw &&\\
      &\ctrl{1} &\qw &&=&&&    &\qw &\qw &\ctrl{2} &\qw  &\qw      &\qw &\ctrl{2} &\qw  &\qw &\qw       &\qw &\qw &\ctrl{2} &\qw  &\qw      &\qw &\ctrl{2} &\qw  &\qw &\qw &&\\
      &\targ    &\qw && &&&    &\qw &\qw &\qw      &\qw  &\qw      &\qw &\qw      &\qw  &\qw &\targ     &\qw &\qw &\qw      &\qw  &\qw      &\qw &\qw      &\qw  &\qw &\qw &&\\
      &         &    && &&&\qO &\qH &\qT &\targ    &\qTi &\targ    &\qT &\targ    &\qTi &\qH &\ctrl{-1} &\qH &\qT &\targ    &\qTi &\targ    &\qT &\targ    &\qTi &\qH &\qw 
          \gategroup{4}{6}{4}{10}{.7em}{--} \gategroup{4}{26}{4}{30}{.7em}{--} &|0\rangle & \\
      &         &    && &&&    &    |A\rangle &  & &     &         &    &         &     &    &          &    &    &         &    &         &     &         &     & |A\rangle
    }
  }
  \caption{
	Performing a Toffoli indirectly, by applying a pair of Toffolis to an ancilla and using the intermediate value to control a CNOT onto the actual target, appears to have a T-count of 8.
	However, the initial T gate is being used to compute an $|A\rangle$ state and the final T gate is being used to uncompute the $|A\rangle$ state.
    Instead of spending $|A\rangle$ states to perform T gates to make and unmake $|A\rangle$ states, we pass in and later recover a single $|A\rangle$ state.
	This ``investment" reduces the net T-count to 6.
  }
  \label{fig:indirect-toffoli}
\end{figure}

A Toffoli with a T-count of 6 isn't optimal, but the reduction from 7 was done in an unexpected way.
While searching for other circuits where this optimization might apply, we realized it would be useful when an initial Toffoli was later uncomputed by a second Toffoli.
Instead of computing and uncomputing the ancilla for the first Toffoli, then recomputing and re-uncomputing the ancilla for the second Toffoli, we simply kept the ancilla around until it was time to uncompute the Toffoli.
This halved the T-count of the pair from 12 to 6.
See \autoref{fig:ancilla-temporary-toffoli}.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1}&\qw &\qw &\qw    &\qw &\qw &\ctrl{1}&\qw && &&&    &\qw     &\qw  &\ctrl{3}&\qw &\qw     &\qw  &\qw &\qw      &\qw &\qw &\qw    &\qw &\qw &\qw      &\qw &\qw &\qw     &\qw  &\ctrl{3}&\qw &\qw     &\qw &&\\
      &\ctrl{1}&\qw &\qw &\qw    &\qw &\qw &\ctrl{1}&\qw &&=&&&    &\ctrl{2}&\qw  &\qw     &\qw &\ctrl{2}&\qw  &\qw &\qw      &\qw &\qw &\qw    &\qw &\qw &\qw      &\qw &\qw &\ctrl{2}&\qw  &\qw     &\qw &\ctrl{2}&\qw &&\\
      &\targ   &\qw &    &\ldots &    &    &\targ   &\qw && &&&    &\qw     &\qw  &\qw     &\qw &\qw     &\qw  &\qw &\targ    &\qw &    &\ldots &    &    &\targ    &\qw &\qw &\qw     &\qw  &\qw     &\qw &\qw     &\qw &&\\
      &        &    &    &       &    &    &        &    && &&&\qA &\targ   &\qTi &\targ   &\qT &\targ   &\qTi &\qH &\ctrl{-1}&\qw &\qw &\qw    &\qw &\qw &\ctrl{-1}&\qH &\qT &\targ   &\qTi &\targ   &\qT &\targ   &\qw &|A\rangle &\\
    }
  }
  \caption{
	Computing and uncomputing a Toffoli gate with a net T-count of 6.
	Invests an $|A\rangle$ state when computing the Toffoli, holds an ancilla qubit storing the logical-AND of the controls until it is time to uncompute the Toffoli, then recovers the $|A\rangle$ state.
  }
  \label{fig:ancilla-temporary-toffoli}
\end{figure}

Many circuits involve computing and later uncomputing a Toffoli (e.g. addition).
Previously, it was believed that each Toffoli had a T-count of 4 so the pair would have a T-count of 8.
Our $|A\rangle$-investing construction state reduces the T-count of the pair from 8 to 6.

We further improve the cost of paired Toffoli gates in the next section, obsoleting the $|A\rangle$-investing construction we just explained.
We covered it regardless, because we believe that investing and recovering $|A\rangle$ states is a useful optimization likely to apply more generally to other kinds of circuits.


\section{Constructing a temporary AND}
\label{sec:temporary-and}

In the previous section, we showed how to compute and uncompute a Toffoli gate by investing an $|A\rangle$ state and performing six $T$ gates.
This construction be improved in several ways, ultimately producing our temporary AND gate construction.

First, the computation step is introducing phase errors (the same ones as in \autoref{fig:bad-phase-toffoli}).
In general, correcting these phase errors requires applying a controlled-S gate to the two controls, and pre-applying a controlled-Z gate involving the target.
However, we know our target is $|0\rangle$ beforehand, so the pre-applied controlled-Z has no effect and can be ignored.
Furthermore, the effect of the controlled-S gate is to apply a phase factor of $i$ to the amplitudes of computational basis states where both controls on.
Our output happens to be a qubit storing whether or not both controls are on, so we can replace the controlled S gate on the controls with an uncontrolled S gate on the ancilla.
This corrects all of the phase errors that were being introduced.

Second, the construction from the previous section is unnecessarily serial.
In the surface code, every T gate hides a measurement and an S gate performed conditional on the outcome of that measurement.
It is beneficial to be waiting for several measurement results in parallel, instead of one after another serially.
As shown in \cite{Jones2013}, the T gates of a Toffoli can all be performed at the same time, and we follow their lead.
Note that we still pass an $|A\rangle$ state into the circuit instead of performing a fourth T gate, because passing in an $|A\rangle$ state already doesn't involve measuring and reacting.

Third, taking another hint from \cite{Jones2013}, we can uncompute the ancilla by using a measure-and-correct process instead of with a mirror of the circuit that computed the ancilla.
To explain the uncomputatoin process, we start with a circuit that obviously performs the uncomputation and then perform simple circuit moves until we arrive at the intended destination.
Our starting point for the uncomputation circuit is simply a Toffoli gate, which obviously clears the ancilla since it was computed with a Toffoli and Toffolis are their own inverse.
Then, since the cleared ancilla is going to be discarded anyways, we are free to apply a Hadamard gate and a measurement to it after the Toffoli but before discarding it.
We then hop the Hadamard over the Toffoli, transforming it into a CCZ operation.
Next we re-arrange the CCZ so that the ancilla is one of the controls, which is possible because the controls and targets of a CCZ are interchangeable.
Finally, we invoke the deferred measurement principle \cite{Nielsen2009} to hop the Measurement over the CCZ, turning the quantum control into a classical control.
Ultimately, the Toffoli gate we started with has been turned into a CZ gate that we apply conditional on the result of measuring the ancilla.
The final circuit uses only Clifford operations, which have no T-count.

With these three improvements applied, we are left with the key ingredients of our temporary AND gate.
We can initialize an ancilla storing the logical-AND of two qubits.
The creation process has a T-count of 4.
Then we can keep the ancilla around, using it as a control for operations that would otherwise have been conditioned on both input qubits.
Finally, once the ancilla is no longer needed, we can erase it at no T-count.

In diagrams, we draw the computation of the AND gate (i.e. the ancilla being initialized) as an ancilla wire emerging vertically from two controls then heading rightward (see \autoref{fig:compute-logical-AND}).
We draw the uncomputation analogously, with the ancilla wire coming in from the left then merging vertically into the two controls that created it (see \autoref{fig:erase-logical-AND}).
The initialized lifetime of the ancilla qubit corresponds to the wire coming out of and later merging into the control qubits.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &x &&\ctrl{1} &\qw & x  && &&          &&\targ    &\ctrl{2}&\qw     &\qTi &\qw     &\ctrl{2}&\targ     &\qw &\qw &\qw &\\
      &y &&\ctrl{1} &\qw & y  &&=&&          &&\targ    &\qw     &\ctrl{1}&\qTi &\ctrl{1}&\qw     &\targ     &\qw &\qw &\qw &\\
      &  &&         &\qw & xy && &&|A\rangle &&\ctrl{-2}&\targ   &\targ   &\qT  &\targ   &\targ   &\ctrl{-2} &\qH &\qS &\qw &\\
    }
  }
  \caption{
	Computing the logical-AND of two qubits, with a T-count of 4 and a T-depth of 1.
  }
  \label{fig:compute-logical-AND}
\end{figure}

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &x  &&\ctrl{1} &\qw &x && &&\qw &\qw    &\ctrl{1} &\qw \\
      &y  &&\ctrl{1} &\qw &y &&=&&\qw &\qw    &\gate{Z} &\qw \\
      &xy &&\qw      &    &  && &&\qH &\meter &\cw \cwx \bullet &    \\
    }
  }
  \caption{
	Uncomputing the logical-AND of two qubits, with a T-count of 0.
  }
  \label{fig:erase-logical-AND}
\end{figure}

We can perform a single Toffoli by computing the logical-AND of two qubits, applying a CNOT from the logical-AND onto the actual target, then uncomputing the logical-AND.
This combined construction, shown in \autoref{fig:merge-use-erase-toffoli}, is equivalent to the one from \cite{Jones2013}.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1} &\qw && &&\ctrl{1} &\qw      &\ctrl{1} &\qw && &&          &&\targ    &\ctrl{2}&\qw     &\qTi &\qw     &\ctrl{2}&\targ     &\qw &\qw &\qw      &\qw &\qw    &\ctrl{1}         &\qw \\
      &\ctrl{2} &\qw && &&\ctrl{1} &\qw      &\ctrl{1} &\qw && &&          &&\targ    &\qw     &\ctrl{1}&\qTi &\ctrl{1}&\qw     &\targ     &\qw &\qw &\qw      &\qw &\qw    &\gate{Z}         &\qw \\
      &         &    &&=&&         &\ctrl{1} &\qw      &    &&=&&|A\rangle &&\ctrl{-2}&\targ   &\targ   &\qT  &\targ   &\targ   &\ctrl{-2} &\qH &\qS &\ctrl{1} &\qH &\meter &\cw \cwx \bullet &    \\
      &\targ    &\qw && &&\qw      &\targ    &\qw      &\qw && &&          &&\qw      &\qw     &\qw     &\qw  &\qw     &\qw     &\qw       &\qw &\qw &\targ    &\qw &\qw    &\qw              &\qw \\
    }
  }
  \caption{
	Performing a Toffoli gate by computing the logical-AND of its controls, using the result, then erasing it.
	Has a T-count of 4 and a measure-react depth of 2.
	Equivalent to the construction from \cite{Jones2013} shown in \autoref{fig:jones-toffoli}.
  }
  \label{fig:merge-use-erase-toffoli}
\end{figure}

In hindsight, our improvement on the construction in \cite{Jones2013} is merely noticing that it can be split it useful pieces that don't all need to be applied at the same time.
In particular, when a Toffoli is later uncomputed by a second Toffoli, simply delaying erasing the ancilla wire as shown in \autoref{fig:paired-toffoli-to-logical-AND} reduces the T-count of such paired Toffolis from 8 to 4.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\ctrl{1} &\qw &\qw &\qw    &\qw &\qw &\ctrl{1} &\qw && &&\ctrl{1} &\qw      &\qw &\qw &\qw    &\qw &\qw &\qw      &\ctrl{1} &\qw & \\
      &\ctrl{2} &\qw &\qw &\qw    &\qw &\qw &\ctrl{2} &\qw && &&\ctrl{1} &\qw      &\qw &\qw &\qw    &\qw &\qw &\qw      &\ctrl{1} &\qw & \\
      &         &    &    &       &    &    &         &    &&=&&         &\ctrl{1} &\qw &\qw &\qw    &\qw &\qw &\ctrl{1} &\qw      &    & \\
      &\targ    &\qw &    &\ldots &    &    &\targ    &\qw && &&\qw      &\targ    &\qw &    &\ldots &    &    &\targ    &\qw      &\qw & \\
    }
  }
  \caption{
	Replacing a pair of compute/uncompute Toffolis with a temporary AND gate and Clifford operations.
	Improves the T-count from 8 to 4.
  }
  \label{fig:paired-toffoli-to-logical-AND}
\end{figure}


\section{Applications}
\label{sec:circuit-constructions}

In this section we will show how to apply temporary Toffolis to improve the complexity of several circuits.

Existing adder constructions such as the Cuccaro adder \cite{Cuccaro2004} contain many Toffolis that are later uncomputed by another Toffoli.
Our improved construction does not fundamentally change the structure of the adder.
We simply perform the temporary Toffoli gates with our temporary AND gate construction, halving the cost.
\autoref{fig:full-adder-block} shows the per-bit building block of our adder construction.
\autoref{fig:multi-bit-adder-example} shows how to tile the building block into a five bit adder.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &c_k &&\ctrl{2}&\qw     &\ctrl{3}&\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\ctrl{3}&\qw     &\ctrl{1}&\qw     &\qw &c_k     &&&&& \\
      &i_k &&\targ   &\ctrl{1}&\qw     &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw     &\ctrl{1}&\targ   &\ctrl{1}&\qw &i_k     &&&&& \\
      &t_k &&\targ   &\ctrl{1}&\qw     &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw     &\ctrl{1}&\qw     &\targ   &\qw &&&(t+i)_k &&& \\
      &    &&        &        &\targ   &\qw &    &c_{k+1}&    &    &    &\ldots &    &    &    &c_{k+1}&    &    &\targ   &\qw     &        &        &    &&&        &&& \\
    }
  }
  \caption{
	Building block, for an adder, with a T-count of 4.
	Equivalent to the building block of the Cuccaro adder \cite{Cuccaro2004}, but using our temporary AND gate construction.
  }
  \label{fig:full-adder-block}
\end{figure}

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &i_0 &&\ctrl{1} &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\ctrl{1}&\qw &i_0     &&&&&\\
      &t_0 &&\ctrl{1} &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\targ   &\qw &&&(t+i)_0 &&&\\
      &    &&         &\ctrl{2}&\qw     &\ctrl{3}&\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{3}&\qw     &\ctrl{1}&\qw     &        &    &&&        &&&\\
      &i_1 &&\qw      &\targ   &\ctrl{1}&\qw     &\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\targ   &\qw     &\ctrl{1}&\qw &i_1     &&&&&\\
      &t_1 &&\qw      &\targ   &\ctrl{1}&\qw     &\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\qw     &\qw     &\targ   &\qw &&&(t+i)_1 &&&\\
      &    &&         &        &        &\targ   &\qw &\ctrl{2}&\qw     &\ctrl{3}&\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{3}&\qw     &\ctrl{1}&\targ   &\qw     &        &        &        &    &&&        &&&\\
      &i_2 &&\qw      &\qw     &\qw     &\qw     &\qw &\targ   &\ctrl{1}&\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\targ   &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\qw &i_2     &&&&&\\
      &t_2 &&\qw      &\qw     &\qw     &\qw     &\qw &\targ   &\ctrl{1}&\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\qw     &\qw     &\qw     &\qw     &\qw     &\targ   &\qw &&&(t+i)_2 &&&\\
      &    &&         &        &        &        &    &        &        &\targ   &\qw &\ctrl{2}&\qw     &\ctrl{3}&\qw     &\ctrl{3}&\qw     &\ctrl{1}&\targ   &\qw     &        &        &        &        &        &        &    &&&        &&&\\
      &i_3 &&\qw      &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw &\targ   &\ctrl{1}&\qw     &\qw     &\qw     &\ctrl{1}&\targ   &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\qw &i_3     &&&&&\\
      &t_3 &&\qw      &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw &\targ   &\ctrl{1}&\qw     &\qw     &\qw     &\ctrl{1}&\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\targ   &\qw &&&(t+i)_3 &&&\\
      &    &&         &        &        &        &    &        &        &        &    &        &        &\targ   &\ctrl{2}&\targ   &\qw     &        &        &        &        &        &        &        &        &        &    &&&        &&&\\
      &i_4 &&\qw      &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\ctrl{1}&\qw &i_4     &&&&&\\
      &t_4 &&\qw      &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\qw &\qw     &\qw     &\qw     &\targ   &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\qw     &\targ   &\qw &&&(t+i)_4 &&&\\
    }
  }
  \caption{
	A 5-bit adder with T-count of 16.
	The circuit contains Clifford operations, four logical-AND computations each with a T-count of 4, and four logical-AND erasures with no T-count.
	Generalizes to an $n$-bit adder with a T-count of $4n - 4$.
  }
  \label{fig:multi-bit-adder-example}
\end{figure}

With a slight tweak to the adder building block, we can make the sum available for use as soon as the carry signal hits the high bit (instead of needing to wait for the uncomputation sweep to finish).
This can halve the T-count of the addition when it is going to be uncomputed.
Instead of paying $4n + O(1)$ T gates to compute the addition, and then $4n + O(1)$ more T gates to uncompute the addition, we simply work with the intermediate state of a single addition computation.
\autoref{fig:temporary-full-adder-block} shows the tweaked building block, which is also a temporary three-bit adder with T-count 4.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &a &&\ctrl{2}&\qw     &\ctrl{3}&\qw     &\qw &a          &&&&&&& \\
      &b &&\targ   &\ctrl{1}&\qw     &\ctrl{1}&\qw &&b \oplus a &&&&&& \\
      &c &&\targ   &\ctrl{1}&\qw     &\targ   &\qw &&&&(a+b+c)_0  &&&& \\
      &  &&        &        &\targ   &\qw     &\qw &&&&(a+b+c)_1  &&&& \\
    }
  }
  \caption{
	  A three-bit adder with T-count 4 that can later be uncomputed for no T-count.
	  A building-block for temporary addition circuits whose result will be used but then uncomputed.
  }
  \label{fig:temporary-full-adder-block}
\end{figure}

Some additions, such as the ones performed in Shor's algorithm, are conditioned on a control qubit.
\cite{Coreas2017} derives a controlled-addition construction with T-count of $21n + O(1)$.
We use our temporary AND gate construction to improve this to $8n + O(1)$, and show the building block in \autoref{fig:controlled-full-adder-block}.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\text{control} &&&&\qw     &\qw     &\qw     &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw     &\qw     &\ctrl{2}&\qw     &\qw &&&\text{control}               &&&&&&\\
      &&c_k            &&&\ctrl{2}&\qw     &\ctrl{3}&\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\ctrl{3}&\qw     &\qw     &\ctrl{2}&\qw &c_k                          &&&&&&&&\\
      &&i_k            &&&\targ   &\ctrl{1}&\qw     &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw     &\ctrl{1}&\ctrl{1}&\targ   &\qw &i_k                          &&&&&&&&\\
      &&t_k            &&&\targ   &\ctrl{1}&\qw     &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw &\qw    &\qw &\qw &\qw     &\ctrl{1}&\targ   &\targ   &\qw &&&&&(t+i \cdot \text{control})_k &&&&&\\
      &               &&&&        &        &\targ   &\qw &    &c_{k+1}&    &    &    &\ldots &    &    &    &c_{k+1}&    &    &\targ   &\qw     &        &        &    &    &&&&&&&&\\
    }
  }
  \caption{
	Building block, for a controlled adder, with a T-count of 8.
  }
  \label{fig:controlled-full-adder-block}
\end{figure}

The temporary AND gate is useful for more than just arithmetic.
For example, temporary ANDs can be useful for applying phase rotations to many qubits simultaneously.
Given a $b$-bit ancilla register $G$ prepared in the state $2^{-b/2} \sum_{k=0}^{2^b-1} e^{2 i \pi k / 2^b} |k\rangle$ (a `phase gradient state'), using our adder construction to add a register $Q$ into $G$ will cause phase kickback that applies the operation $\text{Grad} = \sum_{k=0}^{2^b-1} e^{2 i \pi k / 2^b} |k\rangle \langle k|$ to $V$.
The $\text{Grad}$ operation is equivalent to applying the phase gate $Z^{2^-k}$ to the qubit position at $k$ for each qubit within $Q$.
Some quantum Fourier transform circuits involve conditional uses of $\text{Grad}$, so it is possible that temporary-ANDs improve the T-count of those circuits.

Our constructions reduce many existing estimates of the cost of quantum computation.
For example, \cite{Fowler2012} estimates that factoring a 2000-bit number would take 27 hours and $2 \cdot 10^{12}$ distilled $|A\rangle$.
Their time estimate is based on each Toffoli having a T-depth of 1, and their $|A\rangle$ count estimate is based on Toffolis having a T-count of 7.
Because Shor's algorithm is dominated by the cost of additions, our techniques (and previous work) multiply the T-count by $\frac{4}{14}$ and the T-depth by $\frac{1}{3}$.
This reduces the estimate to 9 hours and $6 \cdot 10^{11}$ distilled $|A\rangle$ states.

Other examples of operations which benefit from cheaper temporary AND gates include:

- Integer comparisons.

- Integer multiplication.

- Incrementing and counting.

- Integer arithmetic in general.

- Modular arithmetic.

- Expanding a binary register into a unary register.

- Operations with a target qubit indexed by a binary qubit register.

- Phasing a register by a computable function $f$ (i.e. applying the operation $U_f = \exp\left( i \sum_k f(k) |k\rangle \langle k| \right)$).

- Temporary permutations.

- Oracles in Grover's algorithm.

We leave further low hanging fruit as exercises for the reader.


\section{Conclusion}
\label{sec:conclusion}

For over a decade, the T-count of addition has been $8n + O(1)$ \cite{Barenco1995, Cuccaro2004, Amy2013}).
This was believed to be optimal \cite{AustinDiscussionsAndEmails2017}.
In this paper, we halved the T-count of addition to $4n + O(1)$.
We did so with a construction that applies to many other circuits: the temporary AND gate.

Our result raises the question of whether further T-count improvements to addition or to temporary AND gates are possible.
A simple method for proving lower bounds on the T-count of an operation is to synthesize T gates by applying that operation.
In \autoref{fig:lower-bound-temporary-and} we use a T gate and a single temporary-AND to synthesize three T gates.
This proves that the T-count of a temporary-AND is at least two.
Two is less than four, but we are not aware of any method for further reducing the T-count of temporary-ANDs or for synthesizing more T gates out of a temporary-AND.

\begin{figure}
  \resizebox{\linewidth}{!}{
    \Qcircuit @R=0.7em @C=0.7em {
      &\qT &\qw && &&&\ctrl{2}&\qw     &\ctrl{3}&\qw     &\qw &\qw     &\ctrl{3}&\qw     &\ctrl{2}&\qw &\\
      &\qT &\qw &&=&&&\targ   &\ctrl{1}&\qw     &\ctrl{1}&\qw &\ctrl{1}&\qw     &\ctrl{1}&\targ   &\qw &\\
      &\qT &\qw && &&&\targ   &\ctrl{1}&\targ   &\targ   &\qT &\targ   &\targ   &\ctrl{1}&\targ   &\qw &\\
      &    &    && &&&        &        &\targ   &\qw     &\qS &\qw     &\targ   &\qw     &        &    &\\
    }
  }
  \caption{
	Three T gates can be synthesized by performing a temporary-AND, one T gate, and various Clifford operations.
	Clifford operations can't produce T gates, so the extra two gates must be coming from the temporary-AND.
	This proves that at least two T gates went into performing the temporary-AND.
  }
  \label{fig:lower-bound-temporary-and}
\end{figure}

Our work represents a significant and widely applicable improvement to the state of the art in synthesizing quantum circuits with low T gate counts.


\section{Acknowledgements}

We thank Austin Fowler for assistance in locating relevant references, sampling the opinions of researchers, and for comments that greatly improved the paper.


\bibliographystyle{plain}
\bibliography{citations}

\end{document}
