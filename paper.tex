\documentclass[twocolumn]{quantumarticle-customized}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage[pdfpagelabels,pdftex,bookmarks,breaklinks]{hyperref}
\usepackage{tikz}
\usepackage[all]{hypcap}
\hypersetup{colorlinks,citecolor=blue,urlcolor=blue,linkcolor=blue}

\def\sectionautorefname{Section}

\begin{document}
\title{Halving the cost of quantum addition}
\author{Craig Gidney}
\affiliation{Google, Santa Barbara, CA 93117, USA}
\email{craiggidney@google.com}

\begin{abstract}
We improve the number of T gates needed to perform an $n$-bit adder from $8n + O(1)$ \cite{Amy2013, Cuccaro2004, AustinDiscussionsAndEmails2017} to $4n + O(1)$.
We do so via a ``temporary logical-AND" construction which uses four T gates to store the logical-AND of two qubits into an ancilla and zero T gates to later erase the ancilla.
This construction is equivalent to one by Jones \cite{Jones2013}, except that our framing makes it clear that the technique is far more widely applicable than previously realized.
Temporary logical-ANDs can be applied to integer arithmetic, modular arithmetic, rotation synthesis, the quantum Fourier transform, Shor's algorithm, Grover oracles, and many other circuits.
Because T gates dominate the cost of quantum computation based on the surface code, and temporary logical-ANDs are widely applicable, this represents a significant reduction in projected costs of quantum computation.
In addition to our $n$-bit adder, we present an $n$-bit controlled adder circuit with T-count of $8n + O(1)$, a temporary adder that can be computed for the same cost as the normal adder but whose result can be kept until it is later uncomputed without using T gates, and discuss some other constructions whose T-count is improved by the temporary logical-AND.
\end{abstract}

\maketitle

\section*{Introduction}

The surface code \cite{Brav98,Denn02,Raus07,Raus07d,Fowler2012} is a quantum error correcting code that works on a 2D nearest-neighbour array of qubits and achieves a threshold error rate of approximately 1\%.
This makes the surface code a likely component in the architecture of future error corrected quantum computers, because 2D arrays of qubits with nearest-neighbor connections are possible with many qubit technologies \cite{Schl11,Bare13,Gamb17,Leik17,Laht17} and other well understood error correcting codes either have lower thresholds or require stronger connectivity.

\begin{figure}
  \includegraphics[width=\linewidth]{adder.pdf}
  \caption{
	A 5-bit adder with T-count of 16.
	Uses Clifford operations, four logical-AND computations each with a T-count of 4, and four logical-AND erasures requiring no T gates.
	Generalizes to an $n$-bit adder with a T-count of $4n - 4$.
	See \autoref{fig:adder-building-block} for the adder building-block and \autoref{fig:temporary-logical-AND} for the logical-AND computation and uncomputation circuits.
  }
  \label{fig:adder}
\end{figure}

One of the downsides of the surface code is that it has no cheap mechanism to apply non-Clifford operations such as $T$ gates.
Instead, $T$ gates are performed by distilling and consuming $|T\rangle = \frac{1}{\sqrt{2}} (|0\rangle + e^{i \pi/4} |1\rangle)$ states.
The T gate is performed via a controlled-NOT from the target qubit into the $|T\rangle$ ancilla, followed by a classical feedback step that measures the ancilla to determine if an $S$ gate is applied to the target.
Unfortunately, distilling the $|T\rangle$ state that will ultimately be passed into this process has significant cost.
The cost of distillation is high enough that error corrected quantum computations are expected to bottleneck waiting for $|T\rangle$ states to be produced, so that their runtime is dominated by the number of T gates (as opposed to more traditional measures of circuit depth).

Because the surface code is a likely component of future quantum computers, and the runtime of computations within the surface code will be dominated in practice by the number of T gates, it is important to optimize the number of T gates used by quantum circuits.
Optimizing the T-count of basic elements of quantum circuits, such as the construction of adders and Toffoli gates, is particularly important because any improvement is widely applicable.

The textbook construction of a Toffoli gate uses seven T gates \cite{Nielsen2009}.
When Toffoli operations are paired, i.e. when an initial Toffoli operation is later uncomputed by a second Toffoli operation, each Toffoli in the pair can omit three of the T gates from the textbook construction.
This introduces phase errors but, assuming intermediate operations aren't sensitive to the phase errors, the second Toffoli gate can uncompute the phase errors while uncomputing the state permutation \cite{Barenco1995, Nielsen2009}.
It is also possible to reduce the T-count of an unpaired Toffoli gate to 4 by using an ancilla qubit and a classically conditioned fixup operation \cite{Jones2013}.

The Cuccaro adder uses $2n + O(1)$ Toffoli gates \cite{Cuccaro2004}.
Existing constructions implement the Cuccaro adder's Toffolis using $8n + O(1)$ T gates \cite{Barenco1995, Cuccaro2004, Amy2013}.
This T-count can be achieved either by applying the ancilla-and-fixup construction from \cite{Jones2013} to each individual Toffoli gate, or by noting that all but one of the adder's Toffoli gates appear in compute/uncompute pairs and then applying the matched-phase-error construction from \cite{Barenco1995, Nielsen2009} to each pair.

\begin{figure}
  \includegraphics[width=\linewidth]{adder-building-block.pdf}
  \caption{
	Our adder circuit building-block, with a T-count of 4.
	A variant of the Cuccaro adder building-block \cite{Cuccaro2004}.
  }
  \label{fig:adder-building-block}
\end{figure}

The leading factor of 8 in the T-count of an $n$-bit adder has stood for over a decade \cite{Barenco1995, Cuccaro2004, AustinDiscussionsAndEmails2017}.
We improve the leading factor with a construction based on the temporary logical-AND, combining ideas from both the matched-phase-error construction and the ancilla-and-fix-up construction.
We thereby halve the number of T gates needed to perform Toffoli gates that appear in compute/uncompute pairs and thus halve the T-count of Cuccaro-style adders from $8n + O(1)$ to $4n + O(1)$.

Although the title of this paper focuses on addition, we consider our main {\em conceptual} contribution to be reframing the ancilla-and-fix-up construction from \cite{Jones2013} into the temporary logical-AND operation.
This conceptualization makes it clear that the construction is more widely applicable than previously realized.
Anytime operations share controls, even if those operations are far apart, a temporary logical-AND allows the controls to be combined once instead of once per operation (as long as intermediate operations are not sensitive to phase error in the controls).
Addition is just one example of an operation where this is beneficial.
We also discuss other examples.


\section*{Resource Tradeoffs}

Before we move on to our results, it is necessary to discuss the tradeoffs between various resources in a quantum computation.
We will address two questions.
First: why the focus on T-count?
Why not circuit depth, or total gate complexity?
Second: what is the opportunity cost of using ancillae qubits?

In error corrected quantum computation based on the surface code, there are four main classes of gates: Pauli operations such as the X and Z gates; unitary Clifford operations such as the CNOT, H, and S gates; Measurement; and non-Clifford operations such as the T gate.

Pauli operations are applied via classical post-processing, and so are considered to be free.
They don't require anything extra to be done to the qubits.

Clifford operations are applied by introducing topological braids or defects throughout the computation.
Braids and defects are interesting because they do not fundamentally distinguish between spacelike and timelike directions.
Long sequences of Clifford operations can be performed instantaneously by laying them out spacewise, or even backwards in time, instead of forward along the time axis.
Multiple Clifford operations can't be scheduled to happen in the same place at the same time, but otherwise there is extreme flexibility in how Clifford operations are placed.
With this flexibility in mind, the cost of a Clifford operation is estimated by how much ``spacetime volume" is used when laying out the associated braid/defect and comparing this against the available spacetime volume during each cycle on a quantum computer of a given size.

Measurements also technically don't have to be laid out in time-respecting directions.
However, if the result of measurement $A$ depends on an operation conditioned on measurement $B$, then measurement $A$ must happen after measurement $B$ in real time.
So measurements have a spacetime volume cost, but they also have an unavoidable time cost.
If a quantum computation has a measurement-depth of 100000 (i.e. has a sequence of 100000 measurements where each depends on the previous), and the round trip time between starting a measurement, reacting to it, and starting the next measurement is 10us, then the computation will take at least one second to complete.

To perform non-Clifford operations, the surface code uses magic state distillation \cite{Fowler2012}.
Distilling a $|T\rangle$ state uses roughly as much spacetime volume as 50 minimum-size \textsc{CNOT} operations.
The T-factory used to achieve this volume has a footprint covering roughly 100 logical qubits worth of area.
On top of the distillation costs, consuming the $|T\rangle$ state to perform a T gate involves a measurement with a conditional fixup operation,
Meaning T gates contribute to the measurement-depth of a circuit.
Other non-Clifford operations are approximated by decomposing them into the Clifford+T gate set.

T gates use over an order of magnitude more spacetime volume than other operations, contain measurements that impose an ordering on the computation, and require huge distillation factories covering hundreds of thousands of physical qubits.
This is why we typically focus on optimizing the T-count of quantum circuits, and treat other operations as having negligible cost.

For truly huge error corrected quantum computers, with enough T factories to produce $|T\rangle$ states faster than they can be consumed, the relevant cost metric does switch from T-count to measurement-depth.
However, anecdotally, measurement-depth is much easier to optimize than T-count.
For example, there are adders with logarithmic measurement-depth [[[cite]]] but there are no adders with logarithmic T-counts.
As another example, Shor's algorithm has a naive measurement-depth of $O(n^3)$ where $n$ is the number of bits in the number to factor.
But, by parallelizing the carries, additions, and multiplications, the measurement-depth can be made polylogarithmic in $n$ [[[cite]]].
For the foreseeable future, anytime one finds that a given circuit for Shor's algorithm is bottlenecked by measurement-depth, one can simply reduce the measurement depth by parallelizing more operations until the T-count becomes the relevant bottleneck again.

We do not claim that the T-count is a perfect representation of the cost of a quantum computation, but it is a reasonable proxy to use when optimizing.

We now move on to addressing the second question: what is the opportunity cost of using ancillae qubits?
Our adder construction consumes $4n$ fewer $|T\rangle$ states than the Cuccaro adder, but in doing so it holds $n$ ancillae through a measurement-depth of $2n$.
Is this tradeoff worth making?
The answer to this complicates the neat and tidy ``just use the T-count" conclusion we stated just last paragraph.

Obviously, if performing an addition on a small quantum computer with no space to spare for additional ancillae, it would be necessary to use an inplace adder instead of our adder.
However, lack of space is not the only reason ancillae can be problematic.
In particular, note that any surface area dedicated to ancillae qubits is surface area {\em not dedicated to T factories}.

Suppose for the sake of argument that a T factory has a footprint covering the equivalent of 100 logical ancillae qubits, and requires a braiding depth of 5 to produce one $|T\rangle$ state (i.e. a $|T\rangle$ state comes out every $5d$ surface code cycles, where $d$ is the code distance).
Then, in an aggregate sense, we may approximate the opportunity cost of holding an ancilla qubit as $\frac{1}{500} |T\rangle$ states per braid depth.

If the opportunity cost of ancillae not used by the Cucarro adder is included in the T-count of our adder, the result is an ``effective" T-count of (roughly) $4n + \frac{1}{500} n^2$.
This means that, for a sufficiently large addition, there must be a crossover point where ancillae are kept so long that the opportunity cost is larger than the $4 |T\rangle$ state savings.
At this crossover, it is better to propagate carries inplace (as in the Cuccarro adder) instead of via ancillae.
(It would still be beneficial to use ancillae for the subset of bits below the cutoff.)
Given the very rough numbers that have already been mentioned, this would happen somewhere around the 2000'th bit of an addition.
However, we caution that this cutoff is a very rough estimate strongly affected by other optimizations and future research and overall system design.
For example, when a logical qubit is kept idle for a long time, it can be temporarily transformed from its ``braidable" form into a ``memory" form that uses significantly less area [[[cite]]].
Idle ancillae, like the ones in our adder, have a lower opportunity cost than active ancillae.
Taking advantage of this would extend the (very rough) cutoff point from being around 2000 to being around 10000.

An interesting consequence of the T-count opportunity cost of ancillae, besides making inplace circuits desirable, is that it makes circuit depth relevant to the T count.
Logarithmic-depth adders may use a constant factor more $|T\rangle$ states and ancillae than our adder, but they use exponentially less {\em ancilla-depth}.
The T-count opportunity cost of logarithmic-depth adders grows like $\Theta(n \lg n)$ instead of like $\Theta(n^2)$.
So, for sufficiently large $n$, their effective T-count is actually lower than the effective T-count of our ripple-carry adder (despite their raw T-count being larger).

Whenever ancillae are used to save T gates, it is important to consider that there may be alternative uses of those ancillae that net more $|T\rangle$ states.
However, these tradeoffs depend strongly on overall system design.
System optimization is important, but it is not the subject of this paper.
We limit ourselves to introducing basic tools (i.e. the concept of a temporary logical-AND, as well as an adder that uses $4$ T gates and one ancillae per bit instead of $8$ T gates per bit) that future system architects can combine with other techniques on a case by case basis.


\section*{Results}

In \autoref{fig:adder}, we present a 5-bit adder with a T-count of 16.
It performs 4 temporary logical-ANDs, each with a T-count of 4.
All other operations are Clifford operations, with no T-count.

The building block of our adder is shown in \autoref{fig:adder-building-block}.
We construct $n$-bit adders by nesting $n$ copies of the building block inside of each other.
The outer-most and inner-most blocks (which act on the low bit and high bit respectively) are then specialized based on the fact that they either have no carry input or no carry output.

Our adder uses temporary logical-AND operations, which we draw as wires emerging out of a pair of controls then later merging into the same pair of controls.
\autoref{fig:temporary-logical-AND} shows how we compute the logical-AND of the two controls, and also the corresponding uncomputation.

Computing the temporary logical-AND has a T-count of 4, but uncomputing it has a T-count of 0.
This surprising asymmetry is due to the fact that measurement is not reversible.
The uncomputation uses measurement in a way that the computation cannot.

\begin{figure}
  \includegraphics[width=\linewidth]{temporary-logical-and.pdf}
  \caption{
	How to compute and uncompute the logical-AND of two qubits.
	The computation circuit (top) has a T-count of 4 and a measurement-depth of 1.
	Note that the $|T\rangle$ state input contributes to the T-count, because $|T\rangle$ states are the resource used to perform T gates.
	The uncomputation circuit (bottom) uses a measure-and-fixup approach \cite{Jones2013} that requires only Clifford gates, and so has a T-count of zero and a measurement-depth of 1.
    \\
    An alternative uncomputation construction is to simply do the reverse of the computation circuit.
    This alternative approach has a net T-count of 2 (because a $|T\rangle$ state is recovered).
    The resulting temporary logical-AND with a T-count of 6 would still be an improvement on existing work, but would be inferior to the measure-and-fixup approach shown above.
  }
  \label{fig:temporary-logical-AND}
\end{figure}


\autoref{fig:other-adder-building-blocks} shows the building-blocks for two variations on our adder: a controlled adder and a temporary adder.

Some additions, such as the ones performed by the multiplications within the modular exponentiation in Shor's algorithm, are conditioned on a control qubit.
Our controlled adder reduces the cost of these additions from $21n + O(1)$ \cite{Coreas2017} to $8n + O(1)$.

Temporary adders are useful when a circuit is going to compute an addition, then later uncompute it.
Instead of paying $4n + O(1)$ T gates to compute an addition, and then $4n + O(1)$ more T gates to uncompute the addition with a subtraction, our temporary adder stops halfway through the normal addition (after all the logical-ANDs have been computed, but before they've been uncomputed) and applies a few cleanup operations so that the sum is available for use.
When the sum is no longer needed, the partially-performed addition is uncomputed instead of completed.

Decreasing the T-count of addition reduces the T-count of any construction based on addition.
For example, in \cite{Fowler2012} it is estimated that factoring a 2048-bit number on a surface-code-based quantum computer would take $2 \cdot 10^{12}$ distilled $|T\rangle$ states and have a measurement-depth spanning 27 hours (though the actual computation would likely be bottlenecked on distillation rather than measurement).
The time estimate assumes Toffolis have a measurement-depth of 3, and the T-count estimate assumes Toffolis have a T-count of 7.
Shor's algorithm is dominated by the cost of controlled additions, so our techniques (and previous work) reduce the average T-count and measurement-depth of the relevant Toffolis to $\sim 2.7$ and $1$ respectively.
This reduces the measurement-depth estimate to 9 hours and the T-count estimate to $8 \cdot 10^{11}$ distilled $|T\rangle$ states.

On top of reducing the T-count of obviously-related classical operations like multiplication and exponentiation, reducing the T-count of addition also reduces the T-count of quantum-specific operations such as rotating qubits.

For example, our improved adder allows the operation $R_Z(\theta)$ to be applied to $n$ qubits with a T-cost of $4n + O(\lg n \lg \frac{1}{\epsilon})$ as follows.
First, iteratively apply our temporary adder to combine the target qubits into a single binary register storing their Hamming weight.
This takes $4n + O(\lg n)$ T gates to do.
Then, for each position $p$ in the Hamming weight register, synthesize and apply the operation $R_Z(\theta \cdot 2^p)$ to the register qubit at that position.
This uses $O(\lg n \lg \frac{1}{\epsilon}$ T gates, which is negligible in comparison to $4n$ for large $n$.
Finally, uncompute the Hamming weight register (using no T gates).
This completes the application of the $n$ desired $R_Z(\theta)$ operations.

Another quantum operation that can be implemented via an adder is the $n$-qubit phase gradient operation $\text{Grad}_n = \sum_{k=0}^{2^n-1} e^{2 i \pi k / 2^n} |k\rangle \langle k|$.
Normally this operation would be implemented by separately applying the operation $R_Z(\pi 2^{-p})$ to each qubit of the target register, where $p$ is the qubit's index in the register and the number of T gates needed for each rotation depends on the maximum per-gate error $\epsilon$.
However, assuming a ``phase gradient register" prepared in the state $2^{-b/2} \sum_{k=0}^{2^b-1} e^{-2 i \pi k / 2^b} |k\rangle$ is available, the phase gradient operation can be performed via addition \cite{Kitaev2002}.
Add the target register into the phase gradient register, and phase kickback will apply the $\text{Grad}_n$ operation to the target.
With our adder, this construction performs phase gradients using $4n + O(1)$ T gates.
Using phase gradients implemented via our adder, approximate quantum Fourier transform was implemented with 3 to 10 times fewer T gates than previous work \cite{Nam2018}.

The phase gradient T-count of $4n + O(1)$ is interesting because it appears to be independent of $\epsilon$ despite the phase gradient operation involving arbitrarily small rotations.
(Anecdotally, this is a somewhat common occurrence when using constructions that use Toffoli gates instead of rotation synthesis.)
However, there are three ways in which this phase gradient construction's cost does depend on $\epsilon$.
First, $\epsilon$ still bounds the minimum quality of the $|T\rangle$ states powering the T gates.
Second, large phase gradients can be truncated down to a size $n_{\text{max}}$ asymptotically equal to $\Theta(\lg \frac{1}{\epsilon})$.
Third, initializing the reusable phase gradient register has a one-time cost of $O(n_{\text{max}} \lg \frac{1}{\epsilon})$ T gates.

\begin{figure}
  \includegraphics[width=\linewidth]{other-adder-building-blocks.pdf}
  \caption{
	Variations on our adder construction.
	(a) is a controlled-adder building-block with a T-count of 8.
	The addition will only occur when the control is on.
	(b) is a temporary-adder building-block with a T-count of 4.
	Has the same T-count as a normal addition, but makes the result available before any uncomputation steps are needed.
	Equivalent to an out-of-place adder, where the result is stored in a separate register.
	Because uncomputing the temporary-adder uses 0 T gates, this implies that uncomputing a register storing $a+b$, when registers storing both $a$ and $b$ are available, requires 0 T gates.
  }
  \label{fig:other-adder-building-blocks}
\end{figure}

The temporary logical-AND is useful for optimizing an even wider variety of circuits than addition is.
Whenever Toffoli gates appear in compute/uncompute pairs, and intermediate operations are not sensitive to phase errors on the controls of the Toffoli gate (i.e. the condition in \autoref{fig:paired-toffoli-replacement-rule} is satisfied), it is possible to save 4 T gates by replacing the pair of Toffoli gates with a temporary logical-AND.

\begin{figure}
  \includegraphics[width=\linewidth]{paired-toffoli-replacement-rule.pdf}
  \caption{
	A sufficient condition for replacing a pair of Toffoli gates with a temporary logical-AND, saving 4 T gates.\\
	1) The later Toffoli gate must be uncomputing the earlier Toffoli gate.\\
	2) Intermediate operations must not be sensitive to the presence of the entangled ancilla.
  }
  \label{fig:paired-toffoli-replacement-rule}
\end{figure}

For example, a simple way to construct Grover oracles starts by translating a classical predicate into a classical reversible circuit made with Toffoli gates.
This reversible circuit is then used on a quantum computer to compute an output qubit, and a Z gate is applied to the output qubit before the circuit is run in reverse to uncompute the output qubit.
Every Toffoli gate generated by this construction is part of a compute/uncompute pair (each Toffoli in the computation will match a Toffoli in the uncomputation).
Using temporary logical-ANDs, instead of individually translating each Toffoli gate into T gates, halves the T-count of this approach to constructing Grover oracles.

As another example, note that the temporary logical-AND can perform NOT gates with many controls by iteratively combining the controls down to a single representative ancilla.
The representative ancilla is then used to control a CNOT onto the target qubit.
This construction takes $4n-4$ T gates to perform a NOT with $n$ controls (and is equivalent to a nesting construction from \cite{Jones2013}).
As when replacing Toffoli gates in compute/uncompute pairs with a temporary logical-AND, the ancilla representing the $n$ controls should be kept and used multiple times whenever possible (instead of being uncomputed and recomputed).

Yet another example of a kind of circuit that benefits from the temporary logical-AND is {\em low-depth} adder circuits.
For example, the Toffoli gates produced by the $P$ and $P^{-1}$ rounds in Draper et al's logarithmic-depth adder \cite{Draper2004} form compute/uncompute pairs that can be replaced by temporary logical-ANDs.
Alternatively, by using temporary logical-ANDs to implement the classical Brent-Kung adder \cite{brent1982} in a reversible fashion, two $N$-bit numbers can be added in $O(\lg N)$ depth with a T-count of only $12N$.

Finally, we note that Toffolis also appear in compute/uncompute pairs in quantum circuits rooted in physics instead of mathematics.
For example, we used temporary logical-ANDs to cut the projected T-count of a step in a chemistry algorithm under development by nearly 30\% \cite{RyanEmails2017}.

\begin{figure}
  \includegraphics[width=\linewidth]{synthesize-t-gates-from-temporary-logical-and.pdf}
  \caption{
	Three T gates can be synthesized by performing a temporary logical-AND, one T gate, and various Clifford operations.
	Clifford operations can't produce T gates, so the extra T gates must be coming from the temporary logical-AND.
	This proves that performing the temporary logical-AND requires at least two T gates.
  }
  \label{fig:synthesize-t-gates-from-temporary-logical-and}
\end{figure}


\section*{Discussion}

For over a decade, the T-count of addition has been $8n + O(1)$ \cite{Amy2013, Barenco1995, Cuccaro2004}.
In this paper we showed how to halve the leading factor of this cost by replacing Toffolis in compute/uncompute pairs with temporary logical-ANDs.
The temporary logical-AND is a basic circuit construction widget that can be used in many circuits, and a good example of measurement breaking the symmetry between computation and uncomputation (allowing one to be more efficient than the other).
We demonstrated how to optimize the T-count of a few tasks using our adder and the temporary logical-AND, but there are many other low hanging applications (e.g. converting between binary and unary, temporary sorting, applying an operation to a qubit indexed by a register in superposition, parameterized bit-rotation of a qubit register, computing the greatest common divisor of two values, etc).

It is interesting to consider if addition or temporary logical-ANDs can be done with still fewer T gates.
\autoref{fig:synthesize-t-gates-from-temporary-logical-and} presents a simple proof that the T-count of the temporary logical-AND is at least 2.
Although we suspect the true lower bound is 4, we also expect that there are special cases with lower T-counts.
For example, if a task involves repeating an action several times (e.g. counting by repeatedly conditionally incrementing a register), T gates from Toffolis in uncomputation work at the end of one repetition may cancel against T gates from Toffolis in computation work at the start of the next repetition.

Regardless of whether there will be further T-count improvements for operations as basic as Toffoli gates appearing in pairs, it is clear that many other kinds of T-count optimizations are waiting to be found.
Not just in the construction of basic low-level operations, but in medium-level constructions, high-level constructions, lower-than-circuit level constructions, and generally across the whole technology stack that will be needed to perform error corrected quantum computation with the surface code for the first time.


\section*{Acknowledgements}

We thank Austin Fowler for sampling the opinions of other researchers, for assistance locating references, and for comments that significantly improved this paper.
We thank Dave Bacon and Dmitri Maslov for comments that significantly improved this paper.

\bibliographystyle{plain}
\bibliography{citations}

\end{document}
